/**
 * Queensaver API
 * Queensaver API to send in sensor data and retrieve it. It\'s also used for user management.
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { Bbox } from '../model/bbox';
// @ts-ignore
import { GenericPostResponse } from '../model/genericPostResponse';
// @ts-ignore
import { GetBboxResponse } from '../model/getBboxResponse';
// @ts-ignore
import { GetHivesResponse } from '../model/getHivesResponse';
// @ts-ignore
import { GetStandsResponse } from '../model/getStandsResponse';
// @ts-ignore
import { GetTemperatureResponse } from '../model/getTemperatureResponse';
// @ts-ignore
import { Hive } from '../model/hive';
// @ts-ignore
import { PostBboxResponse } from '../model/postBboxResponse';
// @ts-ignore
import { PostHivesResponse } from '../model/postHivesResponse';
// @ts-ignore
import { PostStandsResponse } from '../model/postStandsResponse';
// @ts-ignore
import { PutBboxResponse } from '../model/putBboxResponse';
// @ts-ignore
import { PutHiveResponse } from '../model/putHiveResponse';
// @ts-ignore
import { PutStandResponse } from '../model/putStandResponse';
// @ts-ignore
import { Stand } from '../model/stand';
// @ts-ignore
import { Temperature } from '../model/temperature';
// @ts-ignore
import { User } from '../model/user';
// @ts-ignore
import { VarroaScan } from '../model/varroaScan';
// @ts-ignore
import { VarroaScanResponse } from '../model/varroaScanResponse';
// @ts-ignore
import { Weight } from '../model/weight';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class DefaultService {

    protected basePath = 'https://api.queensaver.com/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Get QBox metadata
     * This returns QBox metadata for the logged in user. The request needs to present a valid session cookie. There are no query parameters needed here, the request will return all known bboxes.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public bboxesGet(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<Bbox>>;
    public bboxesGet(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<Bbox>>>;
    public bboxesGet(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<Bbox>>>;
    public bboxesGet(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<Array<Bbox>>(`${this.configuration.basePath}/bboxes`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a bbox
     * This deletes a bbox.
     * @param qToken Either the cookie or this Q-Token must be set to be authorized for the API call.
     * @param uuid The UUID of the bbox.
     * @param token Either this cookie or the Q-Token must be set to be authorized for the API call.
     * @param userId The UserID is set internally and can not set or be overridden with the API request. Please ignore.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public configsBboxDelete(qToken: string, uuid: string, token?: string, userId?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<any>;
    public configsBboxDelete(qToken: string, uuid: string, token?: string, userId?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<HttpResponse<any>>;
    public configsBboxDelete(qToken: string, uuid: string, token?: string, userId?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<HttpEvent<any>>;
    public configsBboxDelete(qToken: string, uuid: string, token?: string, userId?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<any> {
        if (qToken === null || qToken === undefined) {
            throw new Error('Required parameter qToken was null or undefined when calling configsBboxDelete.');
        }
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling configsBboxDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }
        if (uuid !== undefined && uuid !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>uuid, 'uuid');
        }

        let localVarHeaders = this.defaultHeaders;
        if (qToken !== undefined && qToken !== null) {
            localVarHeaders = localVarHeaders.set('Q-Token', String(qToken));
        }

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.delete<any>(`${this.configuration.basePath}/configs/bbox`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Config metadata of bboxes
     * This returns all bboxes of a user
     * @param qToken Either the cookie or this Q-Token must be set to be authorized for the API call.
     * @param token Either this cookie or the Q-Token must be set to be authorized for the API call.
     * @param uuid The UUID of the bbox. If not set, the request will return all bboxes.
     * @param userId The UserID is set internally and can not set or be overridden with the API request. Please ignore.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public configsBboxGet(qToken: string, token?: string, uuid?: string, userId?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<GetBboxResponse>;
    public configsBboxGet(qToken: string, token?: string, uuid?: string, userId?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<GetBboxResponse>>;
    public configsBboxGet(qToken: string, token?: string, uuid?: string, userId?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<GetBboxResponse>>;
    public configsBboxGet(qToken: string, token?: string, uuid?: string, userId?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (qToken === null || qToken === undefined) {
            throw new Error('Required parameter qToken was null or undefined when calling configsBboxGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (uuid !== undefined && uuid !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>uuid, 'uuid');
        }
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (qToken !== undefined && qToken !== null) {
            localVarHeaders = localVarHeaders.set('Q-Token', String(qToken));
        }

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<GetBboxResponse>(`${this.configuration.basePath}/configs/bbox`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create bbox
     * This creates a new bbox. A bbox is a physical hardware component that needs to be associated with a hive.
     * @param qToken Either the cookie or this Q-Token must be set to be authorized for the API call.
     * @param token Either this cookie or the Q-Token must be set to be authorized for the API call.
     * @param userId The UserID is set internally and can not set or be overridden with the API request. Please ignore.
     * @param bbox 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public configsBboxPost(qToken: string, token?: string, userId?: number, bbox?: Bbox, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PostBboxResponse>;
    public configsBboxPost(qToken: string, token?: string, userId?: number, bbox?: Bbox, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PostBboxResponse>>;
    public configsBboxPost(qToken: string, token?: string, userId?: number, bbox?: Bbox, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PostBboxResponse>>;
    public configsBboxPost(qToken: string, token?: string, userId?: number, bbox?: Bbox, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (qToken === null || qToken === undefined) {
            throw new Error('Required parameter qToken was null or undefined when calling configsBboxPost.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (qToken !== undefined && qToken !== null) {
            localVarHeaders = localVarHeaders.set('Q-Token', String(qToken));
        }

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<PostBboxResponse>(`${this.configuration.basePath}/configs/bbox`,
            bbox,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update bbox metadata
     * This call updates bbox metadata
     * @param qToken Either the cookie or this Q-Token must be set to be authorized for the API call.
     * @param uuid The UUID of the bbox. Required. You can only update one bbox at a time.
     * @param token Either this cookie or the Q-Token must be set to be authorized for the API call.
     * @param userId The UserID is set internally and can not set or be overridden with the API request. Please ignore.
     * @param bbox 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public configsBboxPut(qToken: string, uuid: string, token?: string, userId?: number, bbox?: Bbox, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PutBboxResponse>;
    public configsBboxPut(qToken: string, uuid: string, token?: string, userId?: number, bbox?: Bbox, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PutBboxResponse>>;
    public configsBboxPut(qToken: string, uuid: string, token?: string, userId?: number, bbox?: Bbox, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PutBboxResponse>>;
    public configsBboxPut(qToken: string, uuid: string, token?: string, userId?: number, bbox?: Bbox, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (qToken === null || qToken === undefined) {
            throw new Error('Required parameter qToken was null or undefined when calling configsBboxPut.');
        }
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling configsBboxPut.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (uuid !== undefined && uuid !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>uuid, 'uuid');
        }
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (qToken !== undefined && qToken !== null) {
            localVarHeaders = localVarHeaders.set('Q-Token', String(qToken));
        }

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.put<PutBboxResponse>(`${this.configuration.basePath}/configs/bbox`,
            bbox,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * register bbox
     * This registers a new bbox. A bbox is a physical hardware component that needs to be associated with a hive. The bbox sends a registrationId that a user needs to know and put in the system before the registration. The bbox proto is used as a convenience, the only field that is accepted is the bboxId and the registrationId, the hardwareType and that hardwareRevision.
     * @param userId The UserID is set internally and can not set or be overridden with the API request. Please ignore.
     * @param bbox 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public configsBboxRegisterPost(userId?: number, bbox?: Bbox, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<any>;
    public configsBboxRegisterPost(userId?: number, bbox?: Bbox, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<HttpResponse<any>>;
    public configsBboxRegisterPost(userId?: number, bbox?: Bbox, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<HttpEvent<any>>;
    public configsBboxRegisterPost(userId?: number, bbox?: Bbox, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/configs/bbox/register`,
            bbox,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * associate bhive (sensors) with a logical hive
     * This connects a bhive with a hive so all telemetry data will be associate with the hive. If the hiveUuid is empty, we disassociate that bhive (it\&#39;s no longer connected to any hives)
     * @param bhiveId The Mac Address of the QBox client.
     * @param hiveUuid Unique Identifier for this hive
     * @param userId The UserID is set internally and can not set or be overridden with the API request. Please ignore.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public configsBhiveAssociatePost(bhiveId: string, hiveUuid: string, userId?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<any>;
    public configsBhiveAssociatePost(bhiveId: string, hiveUuid: string, userId?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<HttpResponse<any>>;
    public configsBhiveAssociatePost(bhiveId: string, hiveUuid: string, userId?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<HttpEvent<any>>;
    public configsBhiveAssociatePost(bhiveId: string, hiveUuid: string, userId?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<any> {
        if (bhiveId === null || bhiveId === undefined) {
            throw new Error('Required parameter bhiveId was null or undefined when calling configsBhiveAssociatePost.');
        }
        if (hiveUuid === null || hiveUuid === undefined) {
            throw new Error('Required parameter hiveUuid was null or undefined when calling configsBhiveAssociatePost.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }
        if (bhiveId !== undefined && bhiveId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>bhiveId, 'bhiveId');
        }
        if (hiveUuid !== undefined && hiveUuid !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>hiveUuid, 'hiveUuid');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/configs/bhive/associate`,
            null,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a Hive
     * This deletes a hive.
     * @param qToken Either the cookie or this Q-Token must be set to be authorized for the API call.
     * @param uuid The UUID of the hive.
     * @param token Either this cookie or the Q-Token must be set to be authorized for the API call.
     * @param userId The UserID is set internally and can not set or be overridden with the API request. Please ignore.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public hivesDelete(qToken: string, uuid: string, token?: string, userId?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<any>;
    public hivesDelete(qToken: string, uuid: string, token?: string, userId?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<HttpResponse<any>>;
    public hivesDelete(qToken: string, uuid: string, token?: string, userId?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<HttpEvent<any>>;
    public hivesDelete(qToken: string, uuid: string, token?: string, userId?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<any> {
        if (qToken === null || qToken === undefined) {
            throw new Error('Required parameter qToken was null or undefined when calling hivesDelete.');
        }
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling hivesDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }
        if (uuid !== undefined && uuid !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>uuid, 'uuid');
        }

        let localVarHeaders = this.defaultHeaders;
        if (qToken !== undefined && qToken !== null) {
            localVarHeaders = localVarHeaders.set('Q-Token', String(qToken));
        }

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.delete<any>(`${this.configuration.basePath}/hives`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Hive metadata
     * This returns all hive metadata for the currently logged in user. Important to understand is that a user can go back into the past at any point in time (how did my bee hive look like a month or a year ago), so the cloud stores multiple versions of hive metadata. Any PUT request will create a new version. W
     * @param epoch The Unix Time (epoch) that defines the end time of the query. The beginning is defined by the secondsInThePast parameter. If unset, the epoch will be set to NOW()
     * @param secondsInThePast How many seconds we go to the past to return data versions. If set to zero, we will return exactly one version.
     * @param uuid The UUID of the hive. If not set, the request will return all hives.
     * @param userId The UserID is set internally and can not set or be overridden with the API request. Please ignore.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public hivesGet(epoch: number, secondsInThePast: number, uuid?: string, userId?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<GetHivesResponse>;
    public hivesGet(epoch: number, secondsInThePast: number, uuid?: string, userId?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<GetHivesResponse>>;
    public hivesGet(epoch: number, secondsInThePast: number, uuid?: string, userId?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<GetHivesResponse>>;
    public hivesGet(epoch: number, secondsInThePast: number, uuid?: string, userId?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (epoch === null || epoch === undefined) {
            throw new Error('Required parameter epoch was null or undefined when calling hivesGet.');
        }
        if (secondsInThePast === null || secondsInThePast === undefined) {
            throw new Error('Required parameter secondsInThePast was null or undefined when calling hivesGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (uuid !== undefined && uuid !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>uuid, 'uuid');
        }
        if (epoch !== undefined && epoch !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>epoch, 'epoch');
        }
        if (secondsInThePast !== undefined && secondsInThePast !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>secondsInThePast, 'secondsInThePast');
        }
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<GetHivesResponse>(`${this.configuration.basePath}/hives`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Hive metadata
     * This creates a new hive. A hive is a logical representation of a bee hive that can be connected to hardware.
     * @param qToken Either the cookie or this Q-Token must be set to be authorized for the API call.
     * @param token Either this cookie or the Q-Token must be set to be authorized for the API call.
     * @param userId The UserID is set internally and can not set or be overridden with the API request. Please ignore.
     * @param hive 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public hivesPost(qToken: string, token?: string, userId?: number, hive?: Hive, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PostHivesResponse>;
    public hivesPost(qToken: string, token?: string, userId?: number, hive?: Hive, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PostHivesResponse>>;
    public hivesPost(qToken: string, token?: string, userId?: number, hive?: Hive, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PostHivesResponse>>;
    public hivesPost(qToken: string, token?: string, userId?: number, hive?: Hive, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (qToken === null || qToken === undefined) {
            throw new Error('Required parameter qToken was null or undefined when calling hivesPost.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (qToken !== undefined && qToken !== null) {
            localVarHeaders = localVarHeaders.set('Q-Token', String(qToken));
        }

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<PostHivesResponse>(`${this.configuration.basePath}/hives`,
            hive,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Hive metadata
     * This updates hive metadata. Note that internaly we will actally create a new version of the data.
     * @param qToken Either the cookie or this Q-Token must be set to be authorized for the API call.
     * @param token Either this cookie or the Q-Token must be set to be authorized for the API call.
     * @param userId The UserID is set internally and can not set or be overridden with the API request. Please ignore.
     * @param hive 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public hivesPut(qToken: string, token?: string, userId?: number, hive?: Hive, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PutHiveResponse>;
    public hivesPut(qToken: string, token?: string, userId?: number, hive?: Hive, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PutHiveResponse>>;
    public hivesPut(qToken: string, token?: string, userId?: number, hive?: Hive, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PutHiveResponse>>;
    public hivesPut(qToken: string, token?: string, userId?: number, hive?: Hive, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (qToken === null || qToken === undefined) {
            throw new Error('Required parameter qToken was null or undefined when calling hivesPut.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (qToken !== undefined && qToken !== null) {
            localVarHeaders = localVarHeaders.set('Q-Token', String(qToken));
        }

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.put<PutHiveResponse>(`${this.configuration.basePath}/hives`,
            hive,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Authenticate a user against the system.
     * This call is meant for interactive web applications. Be aware that the server returns a cookie with a 24 hour lifetime.
     * @param username Username, must be unique to the queensaver system. We encourage using email-addresses here.
     * @param password Password
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public loginPost(username: string, password: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public loginPost(username: string, password: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public loginPost(username: string, password: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public loginPost(username: string, password: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling loginPost.');
        }
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling loginPost.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/x-www-form-urlencoded'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let localVarFormParams: { append(param: string, value: any): any; };
        let localVarUseForm = false;
        let localVarConvertFormParamsToString = false;
        if (localVarUseForm) {
            localVarFormParams = new FormData();
        } else {
            localVarFormParams = new HttpParams({encoder: this.encoder});
        }

        if (username !== undefined) {
            localVarFormParams = localVarFormParams.append('username', <any>username) as any || localVarFormParams;
        }
        if (password !== undefined) {
            localVarFormParams = localVarFormParams.append('password', <any>password) as any || localVarFormParams;
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/login`,
            localVarConvertFormParamsToString ? localVarFormParams.toString() : localVarFormParams,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Scale values
     * This returns scale values for a certain, defineable date range. The request needs to send a cookie along with the request. The cookie is stored under the key called \&quot;token\&quot;. Note that this returns the scale data for a QBox Client (independent of the beeHive), the API call for an actual beeHive is different.
     * @param qToken Either the cookie or this Q-Token must be set to be authorized for the API call.
     * @param bhiveId The Mac Address of the QBox client. You can get all QBox IDs and clients with the /config API call.
     * @param epoch The Unix Time (epoch) that defines the end time of the scale measurements. The beginning is defined by the secondsInThePast parameter.
     * @param secondsInThePast How many seconds we go to the past to get the data measurements.
     * @param token Either this cookie or the Q-Token must be set to be authorized for the API call.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public scaleGet(qToken: string, bhiveId: string, epoch: number, secondsInThePast: number, token?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<Weight>>;
    public scaleGet(qToken: string, bhiveId: string, epoch: number, secondsInThePast: number, token?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<Weight>>>;
    public scaleGet(qToken: string, bhiveId: string, epoch: number, secondsInThePast: number, token?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<Weight>>>;
    public scaleGet(qToken: string, bhiveId: string, epoch: number, secondsInThePast: number, token?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (qToken === null || qToken === undefined) {
            throw new Error('Required parameter qToken was null or undefined when calling scaleGet.');
        }
        if (bhiveId === null || bhiveId === undefined) {
            throw new Error('Required parameter bhiveId was null or undefined when calling scaleGet.');
        }
        if (epoch === null || epoch === undefined) {
            throw new Error('Required parameter epoch was null or undefined when calling scaleGet.');
        }
        if (secondsInThePast === null || secondsInThePast === undefined) {
            throw new Error('Required parameter secondsInThePast was null or undefined when calling scaleGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (bhiveId !== undefined && bhiveId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>bhiveId, 'bhiveId');
        }
        if (epoch !== undefined && epoch !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>epoch, 'epoch');
        }
        if (secondsInThePast !== undefined && secondsInThePast !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>secondsInThePast, 'secondsInThePast');
        }

        let localVarHeaders = this.defaultHeaders;
        if (qToken !== undefined && qToken !== null) {
            localVarHeaders = localVarHeaders.set('Q-Token', String(qToken));
        }

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<Array<Weight>>(`${this.configuration.basePath}/scale`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Post Scale values
     * Sends a weight from a hive to the queensaver system. The request needs to send a cookie along with the request. The cookie is stored under the key called \&quot;token\&quot;. Note that this returns the scale data for a QBox Client (independent of the beeHive), the API call for an actual beeHive is different.
     * @param qToken Either the cookie or this Q-Token must be set to be authorized for the API call.
     * @param token Either this cookie or the Q-Token must be set to be authorized for the API call.
     * @param userId The User ID. This is used internally and will be overwritten if you send it to the api server. Ignore.
     * @param weight 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public scalePost(qToken: string, token?: string, userId?: number, weight?: Weight, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<GenericPostResponse>;
    public scalePost(qToken: string, token?: string, userId?: number, weight?: Weight, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<GenericPostResponse>>;
    public scalePost(qToken: string, token?: string, userId?: number, weight?: Weight, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<GenericPostResponse>>;
    public scalePost(qToken: string, token?: string, userId?: number, weight?: Weight, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (qToken === null || qToken === undefined) {
            throw new Error('Required parameter qToken was null or undefined when calling scalePost.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (qToken !== undefined && qToken !== null) {
            localVarHeaders = localVarHeaders.set('Q-Token', String(qToken));
        }

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<GenericPostResponse>(`${this.configuration.basePath}/scale`,
            weight,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a stand
     * This deletes a stand. If a stand is deleted, it will only get its deleted field set to true. It will not actually be deleted, because we need to always be able to go back in time.
     * @param qToken Either the cookie or this Q-Token must be set to be authorized for the API call.
     * @param uuid The UUID of the stand.
     * @param token Either this cookie or the Q-Token must be set to be authorized for the API call.
     * @param userId The UserID is set internally and can not set or be overridden with the API request. Please ignore.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public standsDelete(qToken: string, uuid: string, token?: string, userId?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<any>;
    public standsDelete(qToken: string, uuid: string, token?: string, userId?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<HttpResponse<any>>;
    public standsDelete(qToken: string, uuid: string, token?: string, userId?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<HttpEvent<any>>;
    public standsDelete(qToken: string, uuid: string, token?: string, userId?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<any> {
        if (qToken === null || qToken === undefined) {
            throw new Error('Required parameter qToken was null or undefined when calling standsDelete.');
        }
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling standsDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }
        if (uuid !== undefined && uuid !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>uuid, 'uuid');
        }

        let localVarHeaders = this.defaultHeaders;
        if (qToken !== undefined && qToken !== null) {
            localVarHeaders = localVarHeaders.set('Q-Token', String(qToken));
        }

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.delete<any>(`${this.configuration.basePath}/stands`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Stand metadata
     * This returns all hive stand for the currently logged in user. Important to understand is that a user can go back into the past at any point in time (how did my stand look like a month or a year ago), so the cloud stores multiple versions of stand metadata. Any PUT request will create a new version.
     * @param qToken Either the cookie or this Q-Token must be set to be authorized for the API call.
     * @param epoch The Unix Time (epoch) that defines the end time of the query. The beginning is defined by the secondsInThePast parameter. If unset, the epoch will be set to NOW()
     * @param secondsInThePast How many seconds we go to the past to return data versions. If set to zero, we will return exactly one version. If set to non-zero, we will return all results from the past as well, up to 100 values.
     * @param token Either this cookie or the Q-Token must be set to be authorized for the API call.
     * @param uuid The UUID of the stand. If not set, the request will return all stands.
     * @param userId The UserID is set internally and can not set or be overridden with the API request. Please ignore.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public standsGet(qToken: string, epoch: number, secondsInThePast: number, token?: string, uuid?: string, userId?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<GetStandsResponse>;
    public standsGet(qToken: string, epoch: number, secondsInThePast: number, token?: string, uuid?: string, userId?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<GetStandsResponse>>;
    public standsGet(qToken: string, epoch: number, secondsInThePast: number, token?: string, uuid?: string, userId?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<GetStandsResponse>>;
    public standsGet(qToken: string, epoch: number, secondsInThePast: number, token?: string, uuid?: string, userId?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (qToken === null || qToken === undefined) {
            throw new Error('Required parameter qToken was null or undefined when calling standsGet.');
        }
        if (epoch === null || epoch === undefined) {
            throw new Error('Required parameter epoch was null or undefined when calling standsGet.');
        }
        if (secondsInThePast === null || secondsInThePast === undefined) {
            throw new Error('Required parameter secondsInThePast was null or undefined when calling standsGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (uuid !== undefined && uuid !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>uuid, 'uuid');
        }
        if (epoch !== undefined && epoch !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>epoch, 'epoch');
        }
        if (secondsInThePast !== undefined && secondsInThePast !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>secondsInThePast, 'secondsInThePast');
        }
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (qToken !== undefined && qToken !== null) {
            localVarHeaders = localVarHeaders.set('Q-Token', String(qToken));
        }

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<GetStandsResponse>(`${this.configuration.basePath}/stands`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create stand metadata
     * This creates a new stand. A stand is a logical representation of a location of bee hives.
     * @param qToken Either the cookie or this Q-Token must be set to be authorized for the API call.
     * @param token Either this cookie or the Q-Token must be set to be authorized for the API call.
     * @param userId The UserID is set internally and can not set or be overridden with the API request. Please ignore.
     * @param stand 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public standsPost(qToken: string, token?: string, userId?: number, stand?: Stand, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PostStandsResponse>;
    public standsPost(qToken: string, token?: string, userId?: number, stand?: Stand, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PostStandsResponse>>;
    public standsPost(qToken: string, token?: string, userId?: number, stand?: Stand, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PostStandsResponse>>;
    public standsPost(qToken: string, token?: string, userId?: number, stand?: Stand, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (qToken === null || qToken === undefined) {
            throw new Error('Required parameter qToken was null or undefined when calling standsPost.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (qToken !== undefined && qToken !== null) {
            localVarHeaders = localVarHeaders.set('Q-Token', String(qToken));
        }

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<PostStandsResponse>(`${this.configuration.basePath}/stands`,
            stand,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update stand metadata
     * This updates stand metadata. Note that internaly we will actally create a new version of the stand (not the hives). When you issue this call you will have to provide the UUID, otherwise we don\&#39;t know which stand to update. Also any hives attached to the stand will be ignored, you can only update a single stand at any time.
     * @param qToken Either the cookie or this Q-Token must be set to be authorized for the API call.
     * @param token Either this cookie or the Q-Token must be set to be authorized for the API call.
     * @param userId The UserID is set internally and can not set or be overridden with the API request. Please ignore.
     * @param stand 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public standsPut(qToken: string, token?: string, userId?: number, stand?: Stand, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PutStandResponse>;
    public standsPut(qToken: string, token?: string, userId?: number, stand?: Stand, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PutStandResponse>>;
    public standsPut(qToken: string, token?: string, userId?: number, stand?: Stand, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PutStandResponse>>;
    public standsPut(qToken: string, token?: string, userId?: number, stand?: Stand, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (qToken === null || qToken === undefined) {
            throw new Error('Required parameter qToken was null or undefined when calling standsPut.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (qToken !== undefined && qToken !== null) {
            localVarHeaders = localVarHeaders.set('Q-Token', String(qToken));
        }

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.put<PutStandResponse>(`${this.configuration.basePath}/stands`,
            stand,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Temperature values
     * This returns temperate values for a certain, defineable date range. The request needs to send a cookie along with the request. The cookie is stored under the key called \&quot;token\&quot;. Note that this returns the temperature data for a QBox Client (independent of the beeHive), the API call for an actual beeHive is different.
     * @param qToken Either the cookie or this Q-Token must be set to be authorized for the API call.
     * @param bhiveId The Mac Address of the QBox client. You can get all QBox IDs and clients with the /config API call.
     * @param epoch The Unix Time (epoch) that defines the end time of the scale measurements. The beginning is defined by the secondsInThePast parameter.
     * @param secondsInThePast How many seconds we go to the past to get the data measurements.
     * @param token Either this cookie or the Q-Token must be set to be authorized for the API call.
     * @param userId The User ID. This is used internally and will be overwritten if you send it to the api server. Ignore.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public temperatureGet(qToken: string, bhiveId: string, epoch: number, secondsInThePast: number, token?: string, userId?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<GetTemperatureResponse>;
    public temperatureGet(qToken: string, bhiveId: string, epoch: number, secondsInThePast: number, token?: string, userId?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<GetTemperatureResponse>>;
    public temperatureGet(qToken: string, bhiveId: string, epoch: number, secondsInThePast: number, token?: string, userId?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<GetTemperatureResponse>>;
    public temperatureGet(qToken: string, bhiveId: string, epoch: number, secondsInThePast: number, token?: string, userId?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (qToken === null || qToken === undefined) {
            throw new Error('Required parameter qToken was null or undefined when calling temperatureGet.');
        }
        if (bhiveId === null || bhiveId === undefined) {
            throw new Error('Required parameter bhiveId was null or undefined when calling temperatureGet.');
        }
        if (epoch === null || epoch === undefined) {
            throw new Error('Required parameter epoch was null or undefined when calling temperatureGet.');
        }
        if (secondsInThePast === null || secondsInThePast === undefined) {
            throw new Error('Required parameter secondsInThePast was null or undefined when calling temperatureGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (bhiveId !== undefined && bhiveId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>bhiveId, 'bhiveId');
        }
        if (epoch !== undefined && epoch !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>epoch, 'epoch');
        }
        if (secondsInThePast !== undefined && secondsInThePast !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>secondsInThePast, 'secondsInThePast');
        }
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (qToken !== undefined && qToken !== null) {
            localVarHeaders = localVarHeaders.set('Q-Token', String(qToken));
        }

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<GetTemperatureResponse>(`${this.configuration.basePath}/temperature`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Save a new temperature measurement
     * This stores a new temperature measurement in the database. Must be authorized wit ha cookie or a token.
     * @param userId The User ID. This is used internally and will be overwritten if you send it to the api server. Ignore.
     * @param temperature 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public temperaturePost(userId?: number, temperature?: Temperature, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<GenericPostResponse>;
    public temperaturePost(userId?: number, temperature?: Temperature, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<GenericPostResponse>>;
    public temperaturePost(userId?: number, temperature?: Temperature, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<GenericPostResponse>>;
    public temperaturePost(userId?: number, temperature?: Temperature, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<GenericPostResponse>(`${this.configuration.basePath}/temperature`,
            temperature,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a user
     * This call creates a user in the queensaver system.
     * @param user 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userPost(user?: User, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public userPost(user?: User, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public userPost(user?: User, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public userPost(user?: User, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/user`,
            user,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Varroa Scan images and metadata
     * This returns varroa scan metadata. You can search for varroa scans for a certain, defineable date range. The request needs to send a cookie along with the request. The cookie is stored under the key called \&quot;token\&quot;. Note that this returns the image for a QBox Client (independent of the beeHive), the API call for an actual beeHive is different.
     * @param qToken Either the cookie or this Q-Token must be set to be authorized for the API call.
     * @param bhiveId The Mac Address of the QBox client. You can get all QBox IDs and clients with the /config API call.
     * @param token Either this cookie or the Q-Token must be set to be authorized for the API call.
     * @param epoch The Unix Time (epoch) that defines the end time of the varroa images. The beginning is defined by the secondsInThePast parameter.
     * @param uuid The UUID of the varra-scan. If not set, the request will return scans in the given time range. If this parameter is given we ignore all time ranges. This is currently not implemented.
     * @param userId The User ID. This is used internally and will be overwritten if you send it to the api server. Ignore.
     * @param secondsInThePast How many seconds we go to the past to get the data measurements.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public varroaScanGet(qToken: string, bhiveId: string, token?: string, epoch?: number, uuid?: string, userId?: number, secondsInThePast?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<VarroaScanResponse>;
    public varroaScanGet(qToken: string, bhiveId: string, token?: string, epoch?: number, uuid?: string, userId?: number, secondsInThePast?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<VarroaScanResponse>>;
    public varroaScanGet(qToken: string, bhiveId: string, token?: string, epoch?: number, uuid?: string, userId?: number, secondsInThePast?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<VarroaScanResponse>>;
    public varroaScanGet(qToken: string, bhiveId: string, token?: string, epoch?: number, uuid?: string, userId?: number, secondsInThePast?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (qToken === null || qToken === undefined) {
            throw new Error('Required parameter qToken was null or undefined when calling varroaScanGet.');
        }
        if (bhiveId === null || bhiveId === undefined) {
            throw new Error('Required parameter bhiveId was null or undefined when calling varroaScanGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (bhiveId !== undefined && bhiveId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>bhiveId, 'bhiveId');
        }
        if (epoch !== undefined && epoch !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>epoch, 'epoch');
        }
        if (uuid !== undefined && uuid !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>uuid, 'uuid');
        }
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }
        if (secondsInThePast !== undefined && secondsInThePast !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>secondsInThePast, 'secondsInThePast');
        }

        let localVarHeaders = this.defaultHeaders;
        if (qToken !== undefined && qToken !== null) {
            localVarHeaders = localVarHeaders.set('Q-Token', String(qToken));
        }

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<VarroaScanResponse>(`${this.configuration.basePath}/varroa-scan`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Save Varroa Scan image
     * Upload a varroa scan image here. The file is attached via multipart/form-data.
     * @param qToken Either the cookie or this Q-Token must be set to be authorized for the API call.
     * @param token Either this cookie or the Q-Token must be set to be authorized for the API call.
     * @param userId the internal user id of the authenticated user. Will be set internally in the cloud system and does not have an effect if set via the API call as it will be overridden. Don\\\&#39;t set this value.
     * @param bhiveId The Mac Address of the QBox client. You can get all QBox IDs and clients with the /config API call.
     * @param epoch The Unix Time (epoch) that defines the end time of the varroa images. The beginning is defined by the secondsInThePast parameter.
     * @param scan 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public varroaScanImagePost(qToken: string, token?: string, userId?: number, bhiveId?: string, epoch?: number, scan?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<any>;
    public varroaScanImagePost(qToken: string, token?: string, userId?: number, bhiveId?: string, epoch?: number, scan?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<HttpResponse<any>>;
    public varroaScanImagePost(qToken: string, token?: string, userId?: number, bhiveId?: string, epoch?: number, scan?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<HttpEvent<any>>;
    public varroaScanImagePost(qToken: string, token?: string, userId?: number, bhiveId?: string, epoch?: number, scan?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<any> {
        if (qToken === null || qToken === undefined) {
            throw new Error('Required parameter qToken was null or undefined when calling varroaScanImagePost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (qToken !== undefined && qToken !== null) {
            localVarHeaders = localVarHeaders.set('Q-Token', String(qToken));
        }

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let localVarFormParams: { append(param: string, value: any): any; };
        let localVarUseForm = false;
        let localVarConvertFormParamsToString = false;
        if (localVarUseForm) {
            localVarFormParams = new FormData();
        } else {
            localVarFormParams = new HttpParams({encoder: this.encoder});
        }

        if (userId !== undefined) {
            localVarFormParams = localVarFormParams.append('userId', <any>userId) as any || localVarFormParams;
        }
        if (bhiveId !== undefined) {
            localVarFormParams = localVarFormParams.append('bhiveId', <any>bhiveId) as any || localVarFormParams;
        }
        if (epoch !== undefined) {
            localVarFormParams = localVarFormParams.append('epoch', <any>epoch) as any || localVarFormParams;
        }
        if (scan !== undefined) {
            localVarFormParams = localVarFormParams.append('scan', <any>scan) as any || localVarFormParams;
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/varroa-scan-image`,
            localVarConvertFormParamsToString ? localVarFormParams.toString() : localVarFormParams,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Save Varroa Scan metadata
     * This saves varroa scan metadata. This is not callable from an external API.
     * @param userId The User ID. This is used internally and will be overwritten if you send it to the api server. Ignore.
     * @param varroaScan 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public varroaScanPost(userId?: number, varroaScan?: VarroaScan, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<any>;
    public varroaScanPost(userId?: number, varroaScan?: VarroaScan, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<HttpResponse<any>>;
    public varroaScanPost(userId?: number, varroaScan?: VarroaScan, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<HttpEvent<any>>;
    public varroaScanPost(userId?: number, varroaScan?: VarroaScan, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (cookieAuth) required
        localVarCredential = this.configuration.lookupCredential('cookieAuth');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/varroa-scan`,
            varroaScan,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
